{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useState, useEffect } from 'react';\nimport { getActiveTrack } from \"../trackPlayer\";\nimport { Event } from \"../constants\";\nimport { useTrackPlayerEvents } from \"./useTrackPlayerEvents\";\nexport var useActiveTrack = function useActiveTrack() {\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    track = _useState2[0],\n    setTrack = _useState2[1];\n  useEffect(function () {\n    var unmounted = false;\n    getActiveTrack().then(function (initialTrack) {\n      if (unmounted) return;\n      setTrack(function (track) {\n        var _ref;\n        return (_ref = track != null ? track : initialTrack) != null ? _ref : undefined;\n      });\n    }).catch(function () {});\n    return function () {\n      unmounted = true;\n    };\n  }, []);\n  useTrackPlayerEvents([Event.PlaybackActiveTrackChanged], function () {\n    var _ref3 = _asyncToGenerator(function* (_ref2) {\n      var track = _ref2.track;\n      setTrack(track != null ? track : undefined);\n    });\n    return function (_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }());\n  return track;\n};","map":{"version":3,"names":["useState","useEffect","getActiveTrack","Event","useTrackPlayerEvents","useActiveTrack","track","setTrack","unmounted","then","initialTrack","undefined","catch","PlaybackActiveTrackChanged"],"sources":["C:/Users/devandroid/Desktop/TrabajoFinalDAI/node_modules/react-native-track-player/lib/hooks/useActiveTrack.js"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { getActiveTrack } from '../trackPlayer';\nimport { Event } from '../constants';\nimport { useTrackPlayerEvents } from './useTrackPlayerEvents';\nexport const useActiveTrack = () => {\n    const [track, setTrack] = useState();\n    // Sets the initial index (if still undefined)\n    useEffect(() => {\n        let unmounted = false;\n        getActiveTrack()\n            .then((initialTrack) => {\n            if (unmounted)\n                return;\n            setTrack((track) => track ?? initialTrack ?? undefined);\n        })\n            .catch(() => {\n            // throws when you haven't yet setup, which is fine because it also\n            // means there's no active track\n        });\n        return () => {\n            unmounted = true;\n        };\n    }, []);\n    useTrackPlayerEvents([Event.PlaybackActiveTrackChanged], async ({ track }) => {\n        setTrack(track ?? undefined);\n    });\n    return track;\n};\n"],"mappings":";;AAAA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC3C,SAASC,cAAc;AACvB,SAASC,KAAK;AACd,SAASC,oBAAoB;AAC7B,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAc,GAAS;EAChC,gBAA0BL,QAAQ,EAAE;IAAA;IAA7BM,KAAK;IAAEC,QAAQ;EAEtBN,SAAS,CAAC,YAAM;IACZ,IAAIO,SAAS,GAAG,KAAK;IACrBN,cAAc,EAAE,CACXO,IAAI,CAAC,UAACC,YAAY,EAAK;MACxB,IAAIF,SAAS,EACT;MACJD,QAAQ,CAAC,UAACD,KAAK;QAAA;QAAA,eAAKA,KAAK,WAALA,KAAK,GAAII,YAAY,mBAAIC,SAAS;MAAA,EAAC;IAC3D,CAAC,CAAC,CACGC,KAAK,CAAC,YAAM,CAGjB,CAAC,CAAC;IACF,OAAO,YAAM;MACTJ,SAAS,GAAG,IAAI;IACpB,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;EACNJ,oBAAoB,CAAC,CAACD,KAAK,CAACU,0BAA0B,CAAC;IAAA,8BAAE,kBAAqB;MAAA,IAAZP,KAAK,SAALA,KAAK;MACnEC,QAAQ,CAACD,KAAK,WAALA,KAAK,GAAIK,SAAS,CAAC;IAChC,CAAC;IAAA;MAAA;IAAA;EAAA,IAAC;EACF,OAAOL,KAAK;AAChB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}