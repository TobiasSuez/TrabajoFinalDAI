{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useEffect, useState } from 'react';\nimport { getProgress } from \"../trackPlayer\";\nimport { Event } from \"../constants\";\nimport { useTrackPlayerEvents } from \"./useTrackPlayerEvents\";\nvar INITIAL_STATE = {\n  position: 0,\n  duration: 0,\n  buffered: 0\n};\nexport function useProgress() {\n  var updateInterval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n  var _useState = useState(INITIAL_STATE),\n    _useState2 = _slicedToArray(_useState, 2),\n    state = _useState2[0],\n    setState = _useState2[1];\n  useTrackPlayerEvents([Event.PlaybackActiveTrackChanged], function () {\n    setState(INITIAL_STATE);\n  });\n  useEffect(function () {\n    var mounted = true;\n    var update = function () {\n      var _ref = _asyncToGenerator(function* () {\n        try {\n          var _yield$getProgress = yield getProgress(),\n            position = _yield$getProgress.position,\n            duration = _yield$getProgress.duration,\n            buffered = _yield$getProgress.buffered;\n          if (!mounted) return;\n          setState(function (state) {\n            return position === state.position && duration === state.duration && buffered === state.buffered ? state : {\n              position: position,\n              duration: duration,\n              buffered: buffered\n            };\n          });\n        } catch (_unused) {}\n      });\n      return function update() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    var poll = function () {\n      var _ref2 = _asyncToGenerator(function* () {\n        yield update();\n        if (!mounted) return;\n        yield new Promise(function (resolve) {\n          return setTimeout(resolve, updateInterval);\n        });\n        if (!mounted) return;\n        poll();\n      });\n      return function poll() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    poll();\n    return function () {\n      mounted = false;\n    };\n  }, [updateInterval]);\n  return state;\n}","map":{"version":3,"names":["useEffect","useState","getProgress","Event","useTrackPlayerEvents","INITIAL_STATE","position","duration","buffered","useProgress","updateInterval","state","setState","PlaybackActiveTrackChanged","mounted","update","poll","Promise","resolve","setTimeout"],"sources":["C:/Users/devandroid/Desktop/TrabajoFinalDAI/node_modules/react-native-track-player/lib/hooks/useProgress.js"],"sourcesContent":["import { useEffect, useState } from 'react';\nimport { getProgress } from '../trackPlayer';\nimport { Event } from '../constants';\nimport { useTrackPlayerEvents } from './useTrackPlayerEvents';\nconst INITIAL_STATE = {\n    position: 0,\n    duration: 0,\n    buffered: 0,\n};\n/**\n * Poll for track progress for the given interval (in miliseconds)\n * @param updateInterval - ms interval\n */\nexport function useProgress(updateInterval = 1000) {\n    const [state, setState] = useState(INITIAL_STATE);\n    useTrackPlayerEvents([Event.PlaybackActiveTrackChanged], () => {\n        setState(INITIAL_STATE);\n    });\n    useEffect(() => {\n        let mounted = true;\n        const update = async () => {\n            try {\n                const { position, duration, buffered } = await getProgress();\n                if (!mounted)\n                    return;\n                setState((state) => position === state.position &&\n                    duration === state.duration &&\n                    buffered === state.buffered\n                    ? state\n                    : { position, duration, buffered });\n            }\n            catch {\n                // these method only throw while you haven't yet setup, ignore failure.\n            }\n        };\n        const poll = async () => {\n            await update();\n            if (!mounted)\n                return;\n            await new Promise((resolve) => setTimeout(resolve, updateInterval));\n            if (!mounted)\n                return;\n            poll();\n        };\n        poll();\n        return () => {\n            mounted = false;\n        };\n    }, [updateInterval]);\n    return state;\n}\n"],"mappings":";;AAAA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAC3C,SAASC,WAAW;AACpB,SAASC,KAAK;AACd,SAASC,oBAAoB;AAC7B,IAAMC,aAAa,GAAG;EAClBC,QAAQ,EAAE,CAAC;EACXC,QAAQ,EAAE,CAAC;EACXC,QAAQ,EAAE;AACd,CAAC;AAKD,OAAO,SAASC,WAAW,GAAwB;EAAA,IAAvBC,cAAc,uEAAG,IAAI;EAC7C,gBAA0BT,QAAQ,CAACI,aAAa,CAAC;IAAA;IAA1CM,KAAK;IAAEC,QAAQ;EACtBR,oBAAoB,CAAC,CAACD,KAAK,CAACU,0BAA0B,CAAC,EAAE,YAAM;IAC3DD,QAAQ,CAACP,aAAa,CAAC;EAC3B,CAAC,CAAC;EACFL,SAAS,CAAC,YAAM;IACZ,IAAIc,OAAO,GAAG,IAAI;IAClB,IAAMC,MAAM;MAAA,6BAAG,aAAY;QACvB,IAAI;UACA,+BAA+Cb,WAAW,EAAE;YAApDI,QAAQ,sBAARA,QAAQ;YAAEC,QAAQ,sBAARA,QAAQ;YAAEC,QAAQ,sBAARA,QAAQ;UACpC,IAAI,CAACM,OAAO,EACR;UACJF,QAAQ,CAAC,UAACD,KAAK;YAAA,OAAKL,QAAQ,KAAKK,KAAK,CAACL,QAAQ,IAC3CC,QAAQ,KAAKI,KAAK,CAACJ,QAAQ,IAC3BC,QAAQ,KAAKG,KAAK,CAACH,QAAQ,GACzBG,KAAK,GACL;cAAEL,QAAQ,EAARA,QAAQ;cAAEC,QAAQ,EAARA,QAAQ;cAAEC,QAAQ,EAARA;YAAS,CAAC;UAAA,EAAC;QAC3C,CAAC,CACD,gBAAM,CAEN;MACJ,CAAC;MAAA,gBAdKO,MAAM;QAAA;MAAA;IAAA,GAcX;IACD,IAAMC,IAAI;MAAA,8BAAG,aAAY;QACrB,MAAMD,MAAM,EAAE;QACd,IAAI,CAACD,OAAO,EACR;QACJ,MAAM,IAAIG,OAAO,CAAC,UAACC,OAAO;UAAA,OAAKC,UAAU,CAACD,OAAO,EAAER,cAAc,CAAC;QAAA,EAAC;QACnE,IAAI,CAACI,OAAO,EACR;QACJE,IAAI,EAAE;MACV,CAAC;MAAA,gBARKA,IAAI;QAAA;MAAA;IAAA,GAQT;IACDA,IAAI,EAAE;IACN,OAAO,YAAM;MACTF,OAAO,GAAG,KAAK;IACnB,CAAC;EACL,CAAC,EAAE,CAACJ,cAAc,CAAC,CAAC;EACpB,OAAOC,KAAK;AAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}