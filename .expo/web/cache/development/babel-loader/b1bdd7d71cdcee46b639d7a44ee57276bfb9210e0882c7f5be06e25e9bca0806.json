{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport TrackPlayer from '..';\nimport { State } from \"../constants\";\nimport { usePlayWhenReady } from \"./usePlayWhenReady\";\nimport { usePlaybackState } from \"./usePlaybackState\";\nexport function useIsPlaying() {\n  var state = usePlaybackState().state;\n  var playWhenReady = usePlayWhenReady();\n  return determineIsPlaying(playWhenReady, state);\n}\nfunction determineIsPlaying(playWhenReady, state) {\n  if (playWhenReady === undefined || state === undefined) {\n    return {\n      playing: undefined,\n      bufferingDuringPlay: undefined\n    };\n  }\n  var isLoading = state === State.Loading || state === State.Buffering;\n  var isErrored = state === State.Error;\n  var isEnded = state === State.Ended;\n  var isNone = state === State.None;\n  return {\n    playing: playWhenReady && !(isErrored || isEnded || isNone),\n    bufferingDuringPlay: playWhenReady && isLoading\n  };\n}\nexport function isPlaying() {\n  return _isPlaying.apply(this, arguments);\n}\nfunction _isPlaying() {\n  _isPlaying = _asyncToGenerator(function* () {\n    var _yield$Promise$all = yield Promise.all([TrackPlayer.getPlaybackState(), TrackPlayer.getPlayWhenReady()]),\n      _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2),\n      playbackState = _yield$Promise$all2[0],\n      playWhenReady = _yield$Promise$all2[1];\n    return determineIsPlaying(playWhenReady, playbackState.state);\n  });\n  return _isPlaying.apply(this, arguments);\n}","map":{"version":3,"names":["TrackPlayer","State","usePlayWhenReady","usePlaybackState","useIsPlaying","state","playWhenReady","determineIsPlaying","undefined","playing","bufferingDuringPlay","isLoading","Loading","Buffering","isErrored","Error","isEnded","Ended","isNone","None","isPlaying","Promise","all","getPlaybackState","getPlayWhenReady","playbackState"],"sources":["C:/Users/devandroid/Desktop/TrabajoFinalDAI/node_modules/react-native-track-player/lib/hooks/useIsPlaying.js"],"sourcesContent":["import TrackPlayer from '..';\nimport { State } from '../constants';\nimport { usePlayWhenReady } from './usePlayWhenReady';\nimport { usePlaybackState } from './usePlaybackState';\n/**\n * Tells whether the TrackPlayer is in a mode that most people would describe\n * as \"playing.\" Great for UI to decide whether to show a Play or Pause button.\n * @returns playing - whether UI should likely show as Playing, or undefined\n *   if this isn't yet known.\n * @returns bufferingDuringPlay - whether UI should show as Buffering, or\n *   undefined if this isn't yet known.\n */\nexport function useIsPlaying() {\n    const state = usePlaybackState().state;\n    const playWhenReady = usePlayWhenReady();\n    return determineIsPlaying(playWhenReady, state);\n}\nfunction determineIsPlaying(playWhenReady, state) {\n    if (playWhenReady === undefined || state === undefined) {\n        return { playing: undefined, bufferingDuringPlay: undefined };\n    }\n    const isLoading = state === State.Loading || state === State.Buffering;\n    const isErrored = state === State.Error;\n    const isEnded = state === State.Ended;\n    const isNone = state === State.None;\n    return {\n        playing: playWhenReady && !(isErrored || isEnded || isNone),\n        bufferingDuringPlay: playWhenReady && isLoading,\n    };\n}\n/**\n * This exists if you need realtime status on whether the TrackPlayer is\n * playing, whereas the hooks all have a delay because they depend on responding\n * to events before their state is updated.\n *\n * It also exists whenever you need to know the play state outside of a React\n * component, since hooks only work in components.\n *\n * @returns playing - whether UI should likely show as Playing, or undefined\n *   if this isn't yet known.\n * @returns bufferingDuringPlay - whether UI should show as Buffering, or\n *   undefined if this isn't yet known.\n */\nexport async function isPlaying() {\n    const [playbackState, playWhenReady] = await Promise.all([\n        TrackPlayer.getPlaybackState(),\n        TrackPlayer.getPlayWhenReady(),\n    ]);\n    return determineIsPlaying(playWhenReady, playbackState.state);\n}\n"],"mappings":";;AAAA,OAAOA,WAAW,MAAM,IAAI;AAC5B,SAASC,KAAK;AACd,SAASC,gBAAgB;AACzB,SAASC,gBAAgB;AASzB,OAAO,SAASC,YAAY,GAAG;EAC3B,IAAMC,KAAK,GAAGF,gBAAgB,EAAE,CAACE,KAAK;EACtC,IAAMC,aAAa,GAAGJ,gBAAgB,EAAE;EACxC,OAAOK,kBAAkB,CAACD,aAAa,EAAED,KAAK,CAAC;AACnD;AACA,SAASE,kBAAkB,CAACD,aAAa,EAAED,KAAK,EAAE;EAC9C,IAAIC,aAAa,KAAKE,SAAS,IAAIH,KAAK,KAAKG,SAAS,EAAE;IACpD,OAAO;MAAEC,OAAO,EAAED,SAAS;MAAEE,mBAAmB,EAAEF;IAAU,CAAC;EACjE;EACA,IAAMG,SAAS,GAAGN,KAAK,KAAKJ,KAAK,CAACW,OAAO,IAAIP,KAAK,KAAKJ,KAAK,CAACY,SAAS;EACtE,IAAMC,SAAS,GAAGT,KAAK,KAAKJ,KAAK,CAACc,KAAK;EACvC,IAAMC,OAAO,GAAGX,KAAK,KAAKJ,KAAK,CAACgB,KAAK;EACrC,IAAMC,MAAM,GAAGb,KAAK,KAAKJ,KAAK,CAACkB,IAAI;EACnC,OAAO;IACHV,OAAO,EAAEH,aAAa,IAAI,EAAEQ,SAAS,IAAIE,OAAO,IAAIE,MAAM,CAAC;IAC3DR,mBAAmB,EAAEJ,aAAa,IAAIK;EAC1C,CAAC;AACL;AAcA,gBAAsBS,SAAS;EAAA;AAAA;AAM9B;EAAA,+BANM,aAA2B;IAC9B,+BAA6CC,OAAO,CAACC,GAAG,CAAC,CACrDtB,WAAW,CAACuB,gBAAgB,EAAE,EAC9BvB,WAAW,CAACwB,gBAAgB,EAAE,CACjC,CAAC;MAAA;MAHKC,aAAa;MAAEnB,aAAa;IAInC,OAAOC,kBAAkB,CAACD,aAAa,EAAEmB,aAAa,CAACpB,KAAK,CAAC;EACjE,CAAC;EAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}