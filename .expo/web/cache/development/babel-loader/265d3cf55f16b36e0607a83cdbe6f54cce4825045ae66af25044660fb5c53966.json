{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nvar _excluded = [\"alwaysPauseOnInterruption\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport AppRegistry from \"react-native-web/dist/exports/AppRegistry\";\nimport DeviceEventEmitter from \"react-native-web/dist/exports/DeviceEventEmitter\";\nimport NativeEventEmitter from \"react-native-web/dist/exports/NativeEventEmitter\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { default as resolveAssetSource } from 'react-native/Libraries/Image/resolveAssetSource';\nvar TrackPlayer = NativeModules.TrackPlayerModule;\nvar emitter = Platform.OS !== 'android' ? new NativeEventEmitter(TrackPlayer) : DeviceEventEmitter;\nfunction resolveImportedAssetOrPath(pathOrAsset) {\n  var _resolveImportedAsset;\n  return pathOrAsset === undefined ? undefined : typeof pathOrAsset === 'string' ? pathOrAsset : (_resolveImportedAsset = resolveImportedAsset(pathOrAsset)) == null ? void 0 : _resolveImportedAsset.uri;\n}\nfunction resolveImportedAsset(id) {\n  var _resolveAssetSource;\n  return id ? (_resolveAssetSource = resolveAssetSource(id)) != null ? _resolveAssetSource : undefined : undefined;\n}\nexport function setupPlayer() {\n  return _setupPlayer.apply(this, arguments);\n}\nfunction _setupPlayer() {\n  _setupPlayer = _asyncToGenerator(function* () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return TrackPlayer.setupPlayer(options);\n  });\n  return _setupPlayer.apply(this, arguments);\n}\nexport function registerPlaybackService(factory) {\n  if (Platform.OS === 'android') {\n    AppRegistry.registerHeadlessTask('TrackPlayer', factory);\n  } else {\n    setImmediate(factory());\n  }\n}\nexport function addEventListener(event, listener) {\n  return emitter.addListener(event, listener);\n}\nexport function isServiceRunning() {\n  return TrackPlayer.isServiceRunning();\n}\nexport function add(_x) {\n  return _add.apply(this, arguments);\n}\nfunction _add() {\n  _add = _asyncToGenerator(function* (tracks) {\n    var insertBeforeIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var resolvedTracks = (Array.isArray(tracks) ? tracks : [tracks]).map(function (track) {\n      return _objectSpread(_objectSpread({}, track), {}, {\n        url: resolveImportedAssetOrPath(track.url),\n        artwork: resolveImportedAssetOrPath(track.artwork)\n      });\n    });\n    return resolvedTracks.length < 1 ? undefined : TrackPlayer.add(resolvedTracks, insertBeforeIndex);\n  });\n  return _add.apply(this, arguments);\n}\nexport function load(_x2) {\n  return _load.apply(this, arguments);\n}\nfunction _load() {\n  _load = _asyncToGenerator(function* (track) {\n    return TrackPlayer.load(track);\n  });\n  return _load.apply(this, arguments);\n}\nexport function move(_x3, _x4) {\n  return _move.apply(this, arguments);\n}\nfunction _move() {\n  _move = _asyncToGenerator(function* (fromIndex, toIndex) {\n    return TrackPlayer.move(fromIndex, toIndex);\n  });\n  return _move.apply(this, arguments);\n}\nexport function remove(_x5) {\n  return _remove.apply(this, arguments);\n}\nfunction _remove() {\n  _remove = _asyncToGenerator(function* (indexOrIndexes) {\n    return TrackPlayer.remove(Array.isArray(indexOrIndexes) ? indexOrIndexes : [indexOrIndexes]);\n  });\n  return _remove.apply(this, arguments);\n}\nexport function removeUpcomingTracks() {\n  return _removeUpcomingTracks.apply(this, arguments);\n}\nfunction _removeUpcomingTracks() {\n  _removeUpcomingTracks = _asyncToGenerator(function* () {\n    return TrackPlayer.removeUpcomingTracks();\n  });\n  return _removeUpcomingTracks.apply(this, arguments);\n}\nexport function skip(_x6) {\n  return _skip.apply(this, arguments);\n}\nfunction _skip() {\n  _skip = _asyncToGenerator(function* (index) {\n    var initialPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    return TrackPlayer.skip(index, initialPosition);\n  });\n  return _skip.apply(this, arguments);\n}\nexport function skipToNext() {\n  return _skipToNext.apply(this, arguments);\n}\nfunction _skipToNext() {\n  _skipToNext = _asyncToGenerator(function* () {\n    var initialPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    return TrackPlayer.skipToNext(initialPosition);\n  });\n  return _skipToNext.apply(this, arguments);\n}\nexport function skipToPrevious() {\n  return _skipToPrevious.apply(this, arguments);\n}\nfunction _skipToPrevious() {\n  _skipToPrevious = _asyncToGenerator(function* () {\n    var initialPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    return TrackPlayer.skipToPrevious(initialPosition);\n  });\n  return _skipToPrevious.apply(this, arguments);\n}\nexport function updateOptions() {\n  return _updateOptions.apply(this, arguments);\n}\nfunction _updateOptions() {\n  _updateOptions = _asyncToGenerator(function* () {\n    var _options$android$alwa, _options$android;\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var alwaysPauseOnInterruption = _ref.alwaysPauseOnInterruption,\n      options = _objectWithoutProperties(_ref, _excluded);\n    return TrackPlayer.updateOptions(_objectSpread(_objectSpread({}, options), {}, {\n      android: _objectSpread({\n        alwaysPauseOnInterruption: (_options$android$alwa = (_options$android = options.android) == null ? void 0 : _options$android.alwaysPauseOnInterruption) != null ? _options$android$alwa : alwaysPauseOnInterruption\n      }, options.android),\n      icon: resolveImportedAsset(options.icon),\n      playIcon: resolveImportedAsset(options.playIcon),\n      pauseIcon: resolveImportedAsset(options.pauseIcon),\n      stopIcon: resolveImportedAsset(options.stopIcon),\n      previousIcon: resolveImportedAsset(options.previousIcon),\n      nextIcon: resolveImportedAsset(options.nextIcon),\n      rewindIcon: resolveImportedAsset(options.rewindIcon),\n      forwardIcon: resolveImportedAsset(options.forwardIcon)\n    }));\n  });\n  return _updateOptions.apply(this, arguments);\n}\nexport function updateMetadataForTrack(_x7, _x8) {\n  return _updateMetadataForTrack.apply(this, arguments);\n}\nfunction _updateMetadataForTrack() {\n  _updateMetadataForTrack = _asyncToGenerator(function* (trackIndex, metadata) {\n    return TrackPlayer.updateMetadataForTrack(trackIndex, _objectSpread(_objectSpread({}, metadata), {}, {\n      artwork: resolveImportedAssetOrPath(metadata.artwork)\n    }));\n  });\n  return _updateMetadataForTrack.apply(this, arguments);\n}\nexport function clearNowPlayingMetadata() {\n  return TrackPlayer.clearNowPlayingMetadata();\n}\nexport function updateNowPlayingMetadata(metadata) {\n  return TrackPlayer.updateNowPlayingMetadata(_objectSpread(_objectSpread({}, metadata), {}, {\n    artwork: resolveImportedAssetOrPath(metadata.artwork)\n  }));\n}\nexport function reset() {\n  return _reset.apply(this, arguments);\n}\nfunction _reset() {\n  _reset = _asyncToGenerator(function* () {\n    return TrackPlayer.reset();\n  });\n  return _reset.apply(this, arguments);\n}\nexport function play() {\n  return _play.apply(this, arguments);\n}\nfunction _play() {\n  _play = _asyncToGenerator(function* () {\n    return TrackPlayer.play();\n  });\n  return _play.apply(this, arguments);\n}\nexport function pause() {\n  return _pause.apply(this, arguments);\n}\nfunction _pause() {\n  _pause = _asyncToGenerator(function* () {\n    return TrackPlayer.pause();\n  });\n  return _pause.apply(this, arguments);\n}\nexport function stop() {\n  return _stop.apply(this, arguments);\n}\nfunction _stop() {\n  _stop = _asyncToGenerator(function* () {\n    return TrackPlayer.stop();\n  });\n  return _stop.apply(this, arguments);\n}\nexport function setPlayWhenReady(_x9) {\n  return _setPlayWhenReady.apply(this, arguments);\n}\nfunction _setPlayWhenReady() {\n  _setPlayWhenReady = _asyncToGenerator(function* (playWhenReady) {\n    return TrackPlayer.setPlayWhenReady(playWhenReady);\n  });\n  return _setPlayWhenReady.apply(this, arguments);\n}\nexport function getPlayWhenReady() {\n  return _getPlayWhenReady.apply(this, arguments);\n}\nfunction _getPlayWhenReady() {\n  _getPlayWhenReady = _asyncToGenerator(function* () {\n    return TrackPlayer.getPlayWhenReady();\n  });\n  return _getPlayWhenReady.apply(this, arguments);\n}\nexport function seekTo(_x10) {\n  return _seekTo.apply(this, arguments);\n}\nfunction _seekTo() {\n  _seekTo = _asyncToGenerator(function* (position) {\n    return TrackPlayer.seekTo(position);\n  });\n  return _seekTo.apply(this, arguments);\n}\nexport function seekBy(_x11) {\n  return _seekBy.apply(this, arguments);\n}\nfunction _seekBy() {\n  _seekBy = _asyncToGenerator(function* (offset) {\n    return TrackPlayer.seekBy(offset);\n  });\n  return _seekBy.apply(this, arguments);\n}\nexport function setVolume(_x12) {\n  return _setVolume.apply(this, arguments);\n}\nfunction _setVolume() {\n  _setVolume = _asyncToGenerator(function* (level) {\n    return TrackPlayer.setVolume(level);\n  });\n  return _setVolume.apply(this, arguments);\n}\nexport function setRate(_x13) {\n  return _setRate.apply(this, arguments);\n}\nfunction _setRate() {\n  _setRate = _asyncToGenerator(function* (rate) {\n    return TrackPlayer.setRate(rate);\n  });\n  return _setRate.apply(this, arguments);\n}\nexport function setQueue(_x14) {\n  return _setQueue.apply(this, arguments);\n}\nfunction _setQueue() {\n  _setQueue = _asyncToGenerator(function* (tracks) {\n    return TrackPlayer.setQueue(tracks);\n  });\n  return _setQueue.apply(this, arguments);\n}\nexport function setRepeatMode(_x15) {\n  return _setRepeatMode.apply(this, arguments);\n}\nfunction _setRepeatMode() {\n  _setRepeatMode = _asyncToGenerator(function* (mode) {\n    return TrackPlayer.setRepeatMode(mode);\n  });\n  return _setRepeatMode.apply(this, arguments);\n}\nexport function getVolume() {\n  return _getVolume.apply(this, arguments);\n}\nfunction _getVolume() {\n  _getVolume = _asyncToGenerator(function* () {\n    return TrackPlayer.getVolume();\n  });\n  return _getVolume.apply(this, arguments);\n}\nexport function getRate() {\n  return _getRate.apply(this, arguments);\n}\nfunction _getRate() {\n  _getRate = _asyncToGenerator(function* () {\n    return TrackPlayer.getRate();\n  });\n  return _getRate.apply(this, arguments);\n}\nexport function getTrack(_x16) {\n  return _getTrack.apply(this, arguments);\n}\nfunction _getTrack() {\n  _getTrack = _asyncToGenerator(function* (index) {\n    return TrackPlayer.getTrack(index);\n  });\n  return _getTrack.apply(this, arguments);\n}\nexport function getQueue() {\n  return _getQueue.apply(this, arguments);\n}\nfunction _getQueue() {\n  _getQueue = _asyncToGenerator(function* () {\n    return TrackPlayer.getQueue();\n  });\n  return _getQueue.apply(this, arguments);\n}\nexport function getActiveTrackIndex() {\n  return _getActiveTrackIndex.apply(this, arguments);\n}\nfunction _getActiveTrackIndex() {\n  _getActiveTrackIndex = _asyncToGenerator(function* () {\n    var _yield$TrackPlayer$ge;\n    return (_yield$TrackPlayer$ge = yield TrackPlayer.getActiveTrackIndex()) != null ? _yield$TrackPlayer$ge : undefined;\n  });\n  return _getActiveTrackIndex.apply(this, arguments);\n}\nexport function getActiveTrack() {\n  return _getActiveTrack.apply(this, arguments);\n}\nfunction _getActiveTrack() {\n  _getActiveTrack = _asyncToGenerator(function* () {\n    var _yield$TrackPlayer$ge2;\n    return (_yield$TrackPlayer$ge2 = yield TrackPlayer.getActiveTrack()) != null ? _yield$TrackPlayer$ge2 : undefined;\n  });\n  return _getActiveTrack.apply(this, arguments);\n}\nexport function getCurrentTrack() {\n  return _getCurrentTrack.apply(this, arguments);\n}\nfunction _getCurrentTrack() {\n  _getCurrentTrack = _asyncToGenerator(function* () {\n    return TrackPlayer.getActiveTrackIndex();\n  });\n  return _getCurrentTrack.apply(this, arguments);\n}\nexport function getDuration() {\n  return _getDuration.apply(this, arguments);\n}\nfunction _getDuration() {\n  _getDuration = _asyncToGenerator(function* () {\n    return TrackPlayer.getDuration();\n  });\n  return _getDuration.apply(this, arguments);\n}\nexport function getBufferedPosition() {\n  return _getBufferedPosition.apply(this, arguments);\n}\nfunction _getBufferedPosition() {\n  _getBufferedPosition = _asyncToGenerator(function* () {\n    return TrackPlayer.getBufferedPosition();\n  });\n  return _getBufferedPosition.apply(this, arguments);\n}\nexport function getPosition() {\n  return _getPosition.apply(this, arguments);\n}\nfunction _getPosition() {\n  _getPosition = _asyncToGenerator(function* () {\n    return TrackPlayer.getPosition();\n  });\n  return _getPosition.apply(this, arguments);\n}\nexport function getProgress() {\n  return _getProgress.apply(this, arguments);\n}\nfunction _getProgress() {\n  _getProgress = _asyncToGenerator(function* () {\n    return TrackPlayer.getProgress();\n  });\n  return _getProgress.apply(this, arguments);\n}\nexport function getState() {\n  return _getState.apply(this, arguments);\n}\nfunction _getState() {\n  _getState = _asyncToGenerator(function* () {\n    return (yield TrackPlayer.getPlaybackState()).state;\n  });\n  return _getState.apply(this, arguments);\n}\nexport function getPlaybackState() {\n  return _getPlaybackState.apply(this, arguments);\n}\nfunction _getPlaybackState() {\n  _getPlaybackState = _asyncToGenerator(function* () {\n    return TrackPlayer.getPlaybackState();\n  });\n  return _getPlaybackState.apply(this, arguments);\n}\nexport function getRepeatMode() {\n  return _getRepeatMode.apply(this, arguments);\n}\nfunction _getRepeatMode() {\n  _getRepeatMode = _asyncToGenerator(function* () {\n    return TrackPlayer.getRepeatMode();\n  });\n  return _getRepeatMode.apply(this, arguments);\n}\nexport function retry() {\n  return _retry.apply(this, arguments);\n}\nfunction _retry() {\n  _retry = _asyncToGenerator(function* () {\n    return TrackPlayer.retry();\n  });\n  return _retry.apply(this, arguments);\n}","map":{"version":3,"names":["default","resolveAssetSource","TrackPlayer","NativeModules","TrackPlayerModule","emitter","Platform","OS","NativeEventEmitter","DeviceEventEmitter","resolveImportedAssetOrPath","pathOrAsset","undefined","resolveImportedAsset","uri","id","setupPlayer","options","registerPlaybackService","factory","AppRegistry","registerHeadlessTask","setImmediate","addEventListener","event","listener","addListener","isServiceRunning","add","tracks","insertBeforeIndex","resolvedTracks","Array","isArray","map","track","url","artwork","length","load","move","fromIndex","toIndex","remove","indexOrIndexes","removeUpcomingTracks","skip","index","initialPosition","skipToNext","skipToPrevious","updateOptions","alwaysPauseOnInterruption","android","icon","playIcon","pauseIcon","stopIcon","previousIcon","nextIcon","rewindIcon","forwardIcon","updateMetadataForTrack","trackIndex","metadata","clearNowPlayingMetadata","updateNowPlayingMetadata","reset","play","pause","stop","setPlayWhenReady","playWhenReady","getPlayWhenReady","seekTo","position","seekBy","offset","setVolume","level","setRate","rate","setQueue","setRepeatMode","mode","getVolume","getRate","getTrack","getQueue","getActiveTrackIndex","getActiveTrack","getCurrentTrack","getDuration","getBufferedPosition","getPosition","getProgress","getState","getPlaybackState","state","getRepeatMode","retry"],"sources":["C:/Users/devandroid/Desktop/TrabajoFinalDAI/node_modules/react-native-track-player/lib/trackPlayer.js"],"sourcesContent":["import { AppRegistry, DeviceEventEmitter, NativeEventEmitter, NativeModules, Platform, } from 'react-native';\n// @ts-expect-error because resolveAssetSource is untyped\nimport { default as resolveAssetSource } from 'react-native/Libraries/Image/resolveAssetSource';\nconst { TrackPlayerModule: TrackPlayer } = NativeModules;\nconst emitter = Platform.OS !== 'android'\n    ? new NativeEventEmitter(TrackPlayer)\n    : DeviceEventEmitter;\n// MARK: - Helpers\nfunction resolveImportedAssetOrPath(pathOrAsset) {\n    return pathOrAsset === undefined\n        ? undefined\n        : typeof pathOrAsset === 'string'\n            ? pathOrAsset\n            : resolveImportedAsset(pathOrAsset)?.uri;\n}\nfunction resolveImportedAsset(id) {\n    return id\n        ? resolveAssetSource(id) ?? undefined\n        : undefined;\n}\n// MARK: - General API\n/**\n * Initializes the player with the specified options.\n *\n * Note that on Android this method must only be called while the app is in the\n * foreground, otherwise it will throw an error with code\n * `'android_cannot_setup_player_in_background'`. In this case you can wait for\n * the app to be in the foreground and try again.\n *\n * @param options The options to initialize the player with.\n * @see https://rntp.dev/docs/api/functions/lifecycle\n */\nexport async function setupPlayer(options = {}) {\n    return TrackPlayer.setupPlayer(options);\n}\n/**\n * Register the playback service. The service will run as long as the player runs.\n */\nexport function registerPlaybackService(factory) {\n    if (Platform.OS === 'android') {\n        // Registers the headless task\n        AppRegistry.registerHeadlessTask('TrackPlayer', factory);\n    }\n    else {\n        // Initializes and runs the service in the next tick\n        setImmediate(factory());\n    }\n}\nexport function addEventListener(event, listener) {\n    return emitter.addListener(event, listener);\n}\n/**\n * @deprecated This method should not be used, most methods reject when service is not bound.\n */\nexport function isServiceRunning() {\n    return TrackPlayer.isServiceRunning();\n}\nexport async function add(tracks, insertBeforeIndex = -1) {\n    const resolvedTracks = (Array.isArray(tracks) ? tracks : [tracks]).map((track) => ({\n        ...track,\n        url: resolveImportedAssetOrPath(track.url),\n        artwork: resolveImportedAssetOrPath(track.artwork),\n    }));\n    return resolvedTracks.length < 1\n        ? undefined\n        : TrackPlayer.add(resolvedTracks, insertBeforeIndex);\n}\n/**\n * Replaces the current track or loads the track as the first in the queue.\n *\n * @param track The track to load.\n */\nexport async function load(track) {\n    return TrackPlayer.load(track);\n}\n/**\n * Move a track within the queue.\n *\n * @param fromIndex The index of the track to be moved.\n * @param toIndex The index to move the track to. If the index is larger than\n * the size of the queue, then the track is moved to the end of the queue.\n */\nexport async function move(fromIndex, toIndex) {\n    return TrackPlayer.move(fromIndex, toIndex);\n}\nexport async function remove(indexOrIndexes) {\n    return TrackPlayer.remove(Array.isArray(indexOrIndexes) ? indexOrIndexes : [indexOrIndexes]);\n}\n/**\n * Clears any upcoming tracks from the queue.\n */\nexport async function removeUpcomingTracks() {\n    return TrackPlayer.removeUpcomingTracks();\n}\n/**\n * Skips to a track in the queue.\n *\n * @param index The index of the track to skip to.\n * @param initialPosition (Optional) The initial position to seek to in seconds.\n */\nexport async function skip(index, initialPosition = -1) {\n    return TrackPlayer.skip(index, initialPosition);\n}\n/**\n * Skips to the next track in the queue.\n *\n * @param initialPosition (Optional) The initial position to seek to in seconds.\n */\nexport async function skipToNext(initialPosition = -1) {\n    return TrackPlayer.skipToNext(initialPosition);\n}\n/**\n * Skips to the previous track in the queue.\n *\n * @param initialPosition (Optional) The initial position to seek to in seconds.\n */\nexport async function skipToPrevious(initialPosition = -1) {\n    return TrackPlayer.skipToPrevious(initialPosition);\n}\n// MARK: - Control Center / Notifications API\n/**\n * Updates the configuration for the components.\n *\n * @param options The options to update.\n * @see https://rntp.dev/docs/api/functions/player#updateoptionsoptions\n */\nexport async function updateOptions({ alwaysPauseOnInterruption, ...options } = {}) {\n    return TrackPlayer.updateOptions({\n        ...options,\n        android: {\n            // Handle deprecated alwaysPauseOnInterruption option:\n            alwaysPauseOnInterruption: options.android?.alwaysPauseOnInterruption ?? alwaysPauseOnInterruption,\n            ...options.android,\n        },\n        icon: resolveImportedAsset(options.icon),\n        playIcon: resolveImportedAsset(options.playIcon),\n        pauseIcon: resolveImportedAsset(options.pauseIcon),\n        stopIcon: resolveImportedAsset(options.stopIcon),\n        previousIcon: resolveImportedAsset(options.previousIcon),\n        nextIcon: resolveImportedAsset(options.nextIcon),\n        rewindIcon: resolveImportedAsset(options.rewindIcon),\n        forwardIcon: resolveImportedAsset(options.forwardIcon),\n    });\n}\n/**\n * Updates the metadata of a track in the queue. If the current track is updated,\n * the notification and the Now Playing Center will be updated accordingly.\n *\n * @param trackIndex The index of the track whose metadata will be updated.\n * @param metadata The metadata to update.\n */\nexport async function updateMetadataForTrack(trackIndex, metadata) {\n    return TrackPlayer.updateMetadataForTrack(trackIndex, {\n        ...metadata,\n        artwork: resolveImportedAssetOrPath(metadata.artwork),\n    });\n}\n/**\n * @deprecated Nominated for removal in the next major version. If you object\n * to this, please describe your use-case in the following issue:\n * https://github.com/doublesymmetry/react-native-track-player/issues/1653\n */\nexport function clearNowPlayingMetadata() {\n    return TrackPlayer.clearNowPlayingMetadata();\n}\n/**\n * Updates the metadata content of the notification (Android) and the Now Playing Center (iOS)\n * without affecting the data stored for the current track.\n */\nexport function updateNowPlayingMetadata(metadata) {\n    return TrackPlayer.updateNowPlayingMetadata({\n        ...metadata,\n        artwork: resolveImportedAssetOrPath(metadata.artwork),\n    });\n}\n// MARK: - Player API\n/**\n * Resets the player stopping the current track and clearing the queue.\n */\nexport async function reset() {\n    return TrackPlayer.reset();\n}\n/**\n * Plays or resumes the current track.\n */\nexport async function play() {\n    return TrackPlayer.play();\n}\n/**\n * Pauses the current track.\n */\nexport async function pause() {\n    return TrackPlayer.pause();\n}\n/**\n * Stops the current track.\n */\nexport async function stop() {\n    return TrackPlayer.stop();\n}\n/**\n * Sets wether the player will play automatically when it is ready to do so.\n * This is the equivalent of calling `TrackPlayer.play()` when `playWhenReady = true`\n * or `TrackPlayer.pause()` when `playWhenReady = false`.\n */\nexport async function setPlayWhenReady(playWhenReady) {\n    return TrackPlayer.setPlayWhenReady(playWhenReady);\n}\n/**\n * Gets wether the player will play automatically when it is ready to do so.\n */\nexport async function getPlayWhenReady() {\n    return TrackPlayer.getPlayWhenReady();\n}\n/**\n * Seeks to a specified time position in the current track.\n *\n * @param position The position to seek to in seconds.\n */\nexport async function seekTo(position) {\n    return TrackPlayer.seekTo(position);\n}\n/**\n * Seeks by a relative time offset in the current track.\n *\n * @param offset The time offset to seek by in seconds.\n */\nexport async function seekBy(offset) {\n    return TrackPlayer.seekBy(offset);\n}\n/**\n * Sets the volume of the player.\n *\n * @param volume The volume as a number between 0 and 1.\n */\nexport async function setVolume(level) {\n    return TrackPlayer.setVolume(level);\n}\n/**\n * Sets the playback rate.\n *\n * @param rate The playback rate to change to, where 0.5 would be half speed,\n * 1 would be regular speed, 2 would be double speed etc.\n */\nexport async function setRate(rate) {\n    return TrackPlayer.setRate(rate);\n}\n/**\n * Sets the queue.\n *\n * @param tracks The tracks to set as the queue.\n * @see https://rntp.dev/docs/api/constants/repeat-mode\n */\nexport async function setQueue(tracks) {\n    return TrackPlayer.setQueue(tracks);\n}\n/**\n * Sets the queue repeat mode.\n *\n * @param repeatMode The repeat mode to set.\n * @see https://rntp.dev/docs/api/constants/repeat-mode\n */\nexport async function setRepeatMode(mode) {\n    return TrackPlayer.setRepeatMode(mode);\n}\n// MARK: - Getters\n/**\n * Gets the volume of the player as a number between 0 and 1.\n */\nexport async function getVolume() {\n    return TrackPlayer.getVolume();\n}\n/**\n * Gets the playback rate where 0.5 would be half speed, 1 would be\n * regular speed and 2 would be double speed etc.\n */\nexport async function getRate() {\n    return TrackPlayer.getRate();\n}\n/**\n * Gets a track object from the queue.\n *\n * @param index The index of the track.\n * @returns The track object or undefined if there isn't a track object at that\n * index.\n */\nexport async function getTrack(index) {\n    return TrackPlayer.getTrack(index);\n}\n/**\n * Gets the whole queue.\n */\nexport async function getQueue() {\n    return TrackPlayer.getQueue();\n}\n/**\n * Gets the index of the active track in the queue or undefined if there is no\n * current track.\n */\nexport async function getActiveTrackIndex() {\n    return (await TrackPlayer.getActiveTrackIndex()) ?? undefined;\n}\n/**\n * Gets the active track or undefined if there is no current track.\n */\nexport async function getActiveTrack() {\n    return (await TrackPlayer.getActiveTrack()) ?? undefined;\n}\n/**\n * Gets the index of the current track or null if there is no current track.\n *\n * @deprecated use `TrackPlayer.getActiveTrackIndex()` instead.\n */\nexport async function getCurrentTrack() {\n    return TrackPlayer.getActiveTrackIndex();\n}\n/**\n * Gets the duration of the current track in seconds.\n * @deprecated Use `TrackPlayer.getProgress().then((progress) => progress.duration)` instead.\n */\nexport async function getDuration() {\n    return TrackPlayer.getDuration();\n}\n/**\n * Gets the buffered position of the current track in seconds.\n *\n * @deprecated Use `TrackPlayer.getProgress().then((progress) => progress.buffered)` instead.\n */\nexport async function getBufferedPosition() {\n    return TrackPlayer.getBufferedPosition();\n}\n/**\n * Gets the playback position of the current track in seconds.\n * @deprecated Use `TrackPlayer.getProgress().then((progress) => progress.position)` instead.\n */\nexport async function getPosition() {\n    return TrackPlayer.getPosition();\n}\n/**\n * Gets information on the progress of the currently active track, including its\n * current playback position in seconds, buffered position in seconds and\n * duration in seconds.\n */\nexport async function getProgress() {\n    return TrackPlayer.getProgress();\n}\n/**\n * @deprecated use (await getPlaybackState()).state instead.\n */\nexport async function getState() {\n    return (await TrackPlayer.getPlaybackState()).state;\n}\n/**\n * Gets the playback state of the player.\n *\n * @see https://rntp.dev/docs/api/constants/state\n */\nexport async function getPlaybackState() {\n    return TrackPlayer.getPlaybackState();\n}\n/**\n * Gets the queue repeat mode.\n *\n * @see https://rntp.dev/docs/api/constants/repeat-mode\n */\nexport async function getRepeatMode() {\n    return TrackPlayer.getRepeatMode();\n}\n/**\n * Retries the current item when the playback state is `State.Error`.\n */\nexport async function retry() {\n    return TrackPlayer.retry();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}